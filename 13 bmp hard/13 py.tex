\documentclass{article}
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{listings}
\usepackage{setspace,amsmath}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\begin{document}

\begin{titlepage}
	\newpage
	
	\begin{center}
		\textbf{Федеральное государственное бюджетное образовательное учреждение высшего образования «Московский государственный университет имени М. В. Ломоносова»}\\
	\end{center}
	
	\vspace{8em}
	
	\begin{center}
		\Large Кафедра вычислительной механики \\ 
	\end{center}
	
	\vspace{2em}
	
	\begin{center}
		\Large \textsc{\textbf{Отчёт по задаче на работу с изображениями по теме:}}
		\\
		\Large \textsc{\textbf{ Изменение яркости BMP-изображения \linebreak}}
	\end{center}
	
	\vspace{15em}
	
	
	
	\begin{flushright}
		\small
		\textbf{Преподаватель: Почеревин Роман Владимирович}\\
		\textbf{Студент 223 группы: Скворцов Андрей Сергеевич}\\
	\end{flushright}
	
	
	\vspace{\fill}
	
	\begin{center}
		Москва \\2024
	\end{center}
	
\end{titlepage}

\begin{center}


{\large\bf Отчёт по работе с BMP-изображениями в Python-3}
\end{center}
\textit{З\,а\,д\,а\,н\,и\,е.} Реализовать алгоритмы фрактального сжатия и восстановления изображения.

 
\textit{Р\,е\,ш\,е\,н\,и\,е.}  Используя библиотеки numpy и scipy, можно решить эту задачу проще:

\textsf{
	from scipy import ndimage
	import numpy as np }

Пусть изображения заданы внутри программы. Выгрузим его как черно-белое при помощи функции get_greyscale_image(img):
{\usefont{T2A}{cmss}{m}{n}

def get_greyscale_image(img):
	return np.mean(img[:,:,:2], 2)
}

Далее разобьем изображение на нужные нам блоки размера 4 на 4 вместо 8 на 8 при помощи функции reduce(img, factor):
{\usefont{T2A}{cmss}{m}{n}

def reduce(img, factor):
result = np.zeros((img.shape[0] // factor, img.shape[1] // factor))
for i in range(result.shape[0]):
for j in range(result.shape[1]):
result[i, j] = np.mean(img[i * factor:(i + 1) * factor,j * factor:(j + 1) * factor])

return result
}


Теперь рассмотрим сам алгоритм фрактального сжатия изображения. Оно происходит при вызове функции compress. Сначала мы генерируем всевозможные блоки, которые мы можем получить при помощи нашего отображения, при помощи
функции generate_all_transformed_blocks:
 
{\usefont{T2A}{cmss}{m}{n}
def generate_all_transformed_blocks(img, source_size_block, destination_size_block, step):
	factor = source_size_block // destination_size_block
	transformed_blocks = []
	for k in range((img.shape[0] - source_size_block) // step + 1):
		for l in range((img.shape[1] - source_size_block) // step + 1):
			# Преобразуем исходный блок в конечный (доменный -> ранговый)
			S = reduce(img[k * step:k * step + source_size_block,l * step:l * step + source_size_block], factor)
			# Всевозможные преобразования при помощи найшего сжимающего изображения
			for direction, angle in candidates:
				transformed_blocks.append((k, l, direction, angle, apply_transformation(S, direction, angle)))

	return transformed_blocks
}

Далее для каждого блока размером 8 на 8 ищем наиболее похожий на него блок размера 4 на 4:

{\usefont{T2A}{cmss}{m}{n}
def compress(img, source_size_block, destination_size_block, step):
	transformations = []
	transformed_blocks = generate_all_transformed_blocks(img, source_size_block, destination_size_block, step) # Генерируем всевозможные преобразования
	i_count = img.shape[0] // destination_size_block
	j_count = img.shape[1] // destination_size_block
	for i in range(i_count):
		transformations.append([])
		for j in range(j_count):
			# print("{}/{} ; {}/{}".format(i, i_count, j, j_count))
			transformations[i].append(None)
			min_d = float('inf')
			# Берем доменный блок
			D = img[i * destination_size_block:(i + 1) * destination_size_block,j * destination_size_block:(j + 1) * destination_size_block]
			# Выбираем самый похожий блок
			for k, l, direction, angle, S in transformed_blocks:
				contrast, brightness = find_contrast_and_brightness2(D, S)
				S = contrast * S + brightness
				d = np.sum(np.square(D - S)) # Сумма квадратов D - S (типа square это поэлементый квадрат)
				# Ищем самый похожий блок
				if d < min_d:
					min_d = d
					transformations[i][j] = (k, l, direction, angle, contrast, brightness)

	return transformations
}
\vspace{1em}

Теперь рассмотрим алгоритм восстановления описанный в функции decompress. Самое полезное для нас в сжимающем отображении это наличие неподвижных точек в каждом блоке, поэтому для восстановления изображения 
нужно просто применить это отображение несколько раз к массиву полученному при сжатии:

{\usefont{T2A}{cmss}{m}{n}
def decompress(transformations, source_size_block, destination_size_block, step, nb_iter = 8):
	factor = source_size_block // destination_size_block
	height = len(transformations) * destination_size_block
	width = len(transformations[0]) * destination_size_block
	iterations = [np.random.randint(0, 256, (height, width))]
	cur_img = np.zeros((height, width))
	for i_iter in range(nb_iter):
		for i in range(len(transformations)):
			for j in range(len(transformations[i])):
				# Применяем отображение
				k, l, flip, angle, contrast, brightness = transformations[i][j]
				S = reduce(iterations[-1][k * step:k * step + source_size_block,l * step:l * step + source_size_block], factor)
				D = apply_transformation(S, flip, angle, contrast, brightness)
				cur_img[i * destination_size_block:(i + 1) * destination_size_block,j * destination_size_block:(j + 1) * destination_size_block] = D
		iterations.append(cur_img)
		cur_img = np.zeros((height, width))

	return iterations
}
\vspace{1em}


Сохраним изображение и очистим память от элемента $draw$:
\vspace{1em}
	
{\usefont{T2A}{cmss}{m}{n}

imout.save("out.bmp", "BMP")

del draw
}
  
\end{document}